js设计之初为避免同时操作相同Dom元素，js被设计成单线程语言。

浏览器的渲染进程，在解析渲染页面代码要依次生成DOM tree、CSS Tree、再将Dom tree 和 css Tree合并成布局树 （layout tree）
合成布局树的过程中要根据css来计算每个元素的大小、位置，而js能操作Dom 的css样式，所以渲染进程遇到js代码时要同步解析js，同时阻塞后面的渲染。
V8引擎在执行js代码时是单线程执行js代码的，遇到如:定时器、UI事件、xmlHTTPRequrest请求等操作时，同步执行会大大增加js的解析时间，从而阻碍浏览器的渲染，使页面出现卡顿。为了避免此情况出现，需要一套异步机制：事件循环 event loop  来解决问题。

事件循环机制：涉及到 调用栈、消息队列、webAPI 三个概念
调用栈：是js执行过程中存放上下文环境及变量的地方，它是一个栈结构 ，先进后出，解析js时会首先创建一个全局上下文环境压入调用栈中，之后遇到函数在压入调用栈，函数执行完
程之后会从调用栈中弹出
消息队列：用来存放回调任务的，是一个队列结构，先进先出。
web api： 单独的子线程，来注册回调任务 存入消息队列中。

v8引擎主线程解析js文件时，首先往调用栈中压入一个全局上下文环境，遇到函数时，往调用栈中压入函数的上下文函数（函数的作用域），执行完毕之后弹出函数上下文。当解析到异步代码时，如定时器，会把定时器放到web API 子线程中 执行开始计数，主线程继续其它操作。当定时器 到时时，会把回调任务 压入 消息队列中去。等主线程执行完毕之后，在去调用消息队列中的回调任务，依次执行。当把消息队列中的任务执行完毕之后会进入等待进去下一次循环， 此过程为事件循环机制。

事件循环中会有一个问题：一个异步操作执行完毕，要想执行回调操作时，要等到消息队列依次执行到它的回调操作才行。如果它的回调前面有很多其他异步操作回调，那它的执行要等很长时间，如果是UI异步操作的话，会造成用户点击反馈等待时间过长等问题。
为了解决这种问题引入了微任务概念（同时把定时器，UI操作等异步定义为宏任务，存放宏任务的为宏任务消息队列）， v8引擎解析到微任务时，交给web api子线程，webapi 会把微任务回调压入一个专门存放微任务的消息队列，此消息队列是挂载在 调用栈的全局上下文环境中，当主线程执行完毕之后，会检查 微任务消息队列，如果有回调任务，就依次执行（这里有个注意的地方，每次主线执行完毕之后都会清空调用栈的），之后才会去检查宏任务消息，如果有就依次执行。

微任务包括：process.nextTick、Promise、MutationObserver
宏任务包括：各种定时器、发布订阅、I/O操作、UI rendering、requestAnimationFrame

js异步编程 就是让异步操作按照指定的路线进行，且可预测
JS 异步编程进化史：callback -> promise -> generator -> async + await